#include<iostream>
#include<windows.h>
#include <conio.h>

void manual();
void safeFormat(char* diskLetter);
void hardFormat(char* diskLetter);
void systemSafeFormat(char* diskLetter);
void systemHardFormat(char* diskLetter);
void parametresHandler(int argc, char** argv);

using namespace std;

struct bootsector {
    BYTE JumpBoot[3] = { 0xEB };
    BYTE FileSystemName[10] = "EXFAT   ";
    BYTE MustBeZero[53] = { NULL };
    LONG PartitionOffset[2] = { 0 };
    LONG VolumeLength[2] = { 7839657 };
    LONG FatOffset = 24;
    LONG FatLength = 512;
    LONG ClusterHeapOffset = 1048;
    LONG ClusterCount = 1024;
    LONG FirstClusterOfRootDirectory = 2;
    LONG VolumeSerialNumber = 2134;
    BYTE FileSystemRevision[2] = {1,5};//0x105
    BYTE VolumeFlags[2] = { 0 };
    BYTE BytesPerSectorShift = 9;
    BYTE SectorsPerClusterShift = 3;
    BYTE NumberOfFats = 1;
    BYTE DriveSelect = 0x80;
    BYTE PercentInUse = 0xFF;
    BYTE Reserved[7];
    BYTE BootCode[390] = {0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4,0xF4};
    BYTE BootSignature[2] = { 170,85 };//0xaa55
    BYTE ReduntantSpace[512];
};

struct ex_bootsector {
    BYTE ExtendedBootCode[508] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
    DWORD ExtendedBootSignature = 0xAA550000;
};

struct flash_parametres {
    BYTE ParametersGuid[16] = {0x0A,0x0C,0x7E,0x46,0x33,0x99,0x40,0x21,0x90,0xC8,0xFA,0x6D,0x38,0x9C,0x4B,0xA2 };
    DWORD EraseBlockSize = 4096;
    DWORD PageSize = 2048;
    DWORD SpareSectors = 1024;
    DWORD RandomAccessTime = 2000;
    DWORD ProgrammingTime = 2000;
    DWORD ReadCycle = 2000;
    DWORD WriteCycle = 2000;
    DWORD Reserved = {0};

};

struct null_parametres {
    BYTE ParametersGuid[16] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    BYTE Reserved[32] = { 0 };
};

struct oem_parametres {
    flash_parametres f_params;
    null_parametres null_params[9];
    BYTE Reserved[32] = { 0 };
};

DWORD BootChecksum
(
    BYTE* Sectors ,       
    USHORT   BytesPerSector
)
{
    DWORD NumberOfBytes = (DWORD)BytesPerSector * 11;
    DWORD Checksum = 0;
    DWORD Index;

    for (Index = 0; Index < NumberOfBytes; Index++)
    {
        if ((Index == 106) || (Index == 107) || (Index == 112))
        {
            continue;
        }
        Checksum = ((Checksum & 1) ? 0x80000000 : 0) + (Checksum >> 1) + (DWORD)Sectors[Index];
    }

    return Checksum;
}

struct fat {
    DWORD fat_entry[1026] = { 0xFFFFFFF8,0xFFFFFFFF };
    BYTE ExcessSpace[258040];
    
};

struct cluster_heap {
    BYTE Cluster[1024][512] = {0};
};

struct MainBootRegion {
    bootsector mainBootSector;
    ex_bootsector mainExBootSector;
    oem_parametres mainOEMParams;
    BYTE Reserved[512] = { 0 };
};

union MainBootRegionSplitted {
    MainBootRegion mbr;
    BYTE array[sizeof(MainBootRegion)] = { 0 };
}mbrSplitted;


struct BackUpBootRegion {
    bootsector mainBootSector;
    ex_bootsector mainExBootSector;
    oem_parametres mainOEMParams;
    BYTE Reserved[512] = { 0 };
};

union BackupBootRegionSplitted {
    BackUpBootRegion mbr;
    BYTE array[sizeof(BackUpBootRegion)] = {0};
}bbrSplitted;

struct VolumeStructure {
    // main boot region
    MainBootRegion mbr;
    DWORD mainBootCheckSum = BootChecksum(mbrSplitted.array, 512);
    // back up boot region
    BackUpBootRegion bbr;
    DWORD backupBootCheckSum = BootChecksum(bbrSplitted.array, 512);
    //FAT region
    fat firstFAT;
    fat secondFAT;
    // DATA REGION
    cluster_heap clusterHeap;
    BYTE ExcessSpace[7314321] = {0};
};

int main(int argc, char** argv)
{
    setlocale(LC_ALL, "Rus");
    parametresHandler(argc, argv);
    return 0;
 }


void manual() {
    system("CLS");
    cout << "Эта утилита предначначена для форматирования носителей информации в файловую сисетму exFAT." << endl;
    cout << "___________________________________________________________________________________________" << endl;
    cout << "Вы можете использовать 3 ключа при запуске этой утилиты:___________________________________" << endl;
    cout << "1. man - чтоб оказаться здесь._____________________________________________________________" << endl;
    cout << "2. -s  - для быстрого форматирования диска.________________________________________________" << endl;
    cout << "3. -h  - для полного форматирования диска._________________________________________________" << endl;
    cout << "3. -ss - для быстрого форматирования диска системной утилитой._____________________________" << endl;
    cout << "3. -sh - для полного форматирования диска системной утилитой.______________________________" << endl;
    cout << "___________________________________________________________________________________________" << endl;
    cout << "При запуске программы вы можете использовать не более одного из вышеперечисленных ключей.__" << endl;
    cout << "Быстрое форматирование используется по умолчанию.__________________________________________" << endl;
    cout << "Вы должны указывать литеру диска при каждом запуске программы, кроме вызова этого мануала._" << endl;
    cout << "Литера диска должна иметь формат - \"Х:\".___________________________________________________" << endl;
}

void safeFormat(char* diskLetter) {
    char diskName[8] = "\\\\.\\";
    strcat_s(diskName,8, diskLetter);
    LPWSTR LCPWDiskName = new wchar_t[8];
    MultiByteToWideChar(CP_ACP, MB_COMPOSITE, diskName, 8, LCPWDiskName, 8);
    HANDLE hDisk = ::CreateFile(LCPWDiskName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        cout << "Ошибка при открытии диска" << endl;
        return;
    }

    VolumeStructure *volumeStructure = new VolumeStructure;
    for (int i = 2; i < 1026; i++) {
        volumeStructure->firstFAT.fat_entry[i] = i;
        volumeStructure->secondFAT.fat_entry[i] = i;
    }

    // записать на диск
    WriteFile(hDisk, volumeStructure, sizeof(VolumeStructure), NULL, NULL);
    CloseHandle(hDisk);

}

void hardFormat(char* diskLetter) {
    char diskName[8] = "\\\\.\\";
    strcat_s(diskName, 8, diskLetter);
    LPWSTR LCPWDiskName = new wchar_t[8];
    MultiByteToWideChar(CP_ACP, MB_COMPOSITE, diskName, 8, LCPWDiskName, 8);
    DeleteFile(LCPWDiskName);
    //записать структуру
    HANDLE hDisk = ::CreateFile(LCPWDiskName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        cout << "Ошибка при открытии диска" << endl;
        return;
    }

    VolumeStructure* volumeStructure = new VolumeStructure;
    for (int i = 2; i < 1026; i++) {
        volumeStructure->firstFAT.fat_entry[i] = i;
        volumeStructure->secondFAT.fat_entry[i] = i;
    }


    WriteFile(hDisk, volumeStructure, sizeof(VolumeStructure), NULL, NULL);
    CloseHandle(hDisk);
 
}

void systemSafeFormat(char* diskLetter) {
    char comStart[25] = "format ";
    strcat_s(comStart, 25, diskLetter);
    char comEnd[20] = "/fs:exfat /q";
    strcat_s(comStart, 25, comEnd);
    system(comStart);

}

void systemHardFormat(char* diskLetter) {
    char comStart[25] = "format";
    strcat_s(comStart, 25, diskLetter);
    char comEnd[20] = "/fs:exfat";
    strcat_s(comStart, 25, comEnd);
    system(comStart);
}

void parametresHandler(int argc, char** argv) {
    if (argc == 1 || argc > 3) {
        cout << "Неверные параметры" << endl;
        return;
    }
    else if (argc == 2) {
        if (strcmp(argv[1], "man") == 0) {
            manual();
        }
        else
        {
            safeFormat(argv[1]);
        }
    }
    else if (argc == 3) {
        if (strcmp(argv[2], "-h") == 0) {
            //полное форматироание
            hardFormat(argv[1]);
        }
        else if (strcmp(argv[2], "-s") == 0) {
            //быстрое форматирование
            safeFormat(argv[1]);
        }
        else if (strcmp(argv[2], "-ss") == 0) {
            systemSafeFormat(argv[1]);
        }
        else if (strcmp(argv[2], "-sh") == 0) {
            systemHardFormat(argv[1]);
        }
        else {
            std::cout << "Неверные параметры" << std::endl;
            return;
        }
    }
}
